#+STARTUP: showall indent
#+STARTUP: hidestars
#+BEGIN_EXPORT html
---
layout: post
title: Literate adventures in C - warming up
tags:
  -
author: Willem van den Ende
image: /attachments/blogposts/2021/tpop-book-cover.jpg
---
#+END_EXPORT

[[https://www.jezuk.co.uk/about.html][Jez Higgins ]]and [[http://www.chrisoldwood.com/articles.htm][Chris Oldwood]] recommended [[https://www.cs.princeton.edu/~bwk/tpop.webpage/][The Practice of Programming]] book to me when we were working on an enterprise C++ project. It is from the same year as my beloved Extreme Programming Explained, but quite different. It is multi-language, but some of the exercises are in ~C~ (not surprising, given the authors). I got started on it last year, but life got in the way, and I needed to practice my C a bit before being able to do anything meaningful in it. Now that Rob and I are prepping for a C++ TDD / Legacy code training next month, I'm in the right frame of mind to also dive deeper into C.

file:../attachments/blogposts/2021/tpop-book-cover.jpg

I showed this to Marc and Rob and they thought it was fun. I'm also sharing some of the failures, following a recent discussion on twitter that people only publish things when they gone well, or when they have been heavily edited. This may lead readers to believe that they could not possibly do such a thing.


* Why on earth would you program in C?

The 'logical' reason is that ~C~ is still one of the best languages to maintain existing ~C~ programs in. Your house probably runs on a few million lines of ~C~ code (in your heating, your ovens, kitchen timers, smart meters, and for me every year since 2000 has been the year of linux on the desktop, and guess what the linux kernel is made of?. My editor may look lispy, but is also built on C). So learning a bit of C is good, even if it just to get over ones' fear of the unknown.

The illogical reason is that programming in ~C~ is like leaving your comfy dwelling, and going camping in a tent, possibly with some thunder storms around. Programming in a language where the ~unsafe~ keyword is called ~int main()~ is just fun!

If you told me 25 years ago I would say I would program C for relaxation, I might have disagreed. I had been taught program with pointers, but making a mistake often meant a blue screen, and a minutes long reboot of my computer. So I dabbled in C, and soon left for more comfortable environments. In a Unix (this post was written on MacOs and Linux), C's natural habitat, the experience is different: a segfault just means a message in my editors' window and another quick try. Computers are now fast enough to compile a bit of ~C~ in an instant.

* The one thing I wished I had known when learning C

Was working in baby steps. Admittedly, getting evenings full of blue screens and reboots was not very motivating. I figured this out a couple of years later, when I was working in a C++ codebase. The Solaris tooling had a debugger that would let me make some changes in an implementation (.cpp) file, and restart an execution from where it was. I couldn't believe it was not Smalltalk. I learnt working in baby steps, because the compile times in that project were long, and it took me a month of working like that to get them into a doable state (45 minutes down to 5 or so).

** How to do baby steps in C then?

I decided to not leave the comfort of my editor ([[https://www.orgroam.com][org-roam]] inside [[https://github.com/hlissner/doom-emacs][Doom Emacs]]), and do literate programming for a bit. This means I can write a bit of code, and write my thoughts about it right where I am. The warm up was easy, refactoring required learning a bit more about org-babel. I've put the resources I found useful at the end of the post.


I've used this setup before for emacs lisp, but not for C, so I wasn't sure what to expect. Let's start with hello world.

#+begin_src C
printf("Hello org-babel again!");
#+end_src

#+RESULTS:
: Hello org-babel again!

Pressing ctrl-c, ctrl-c generates a ~main()~ function, builds it, and if successful, runs it. And puts the results in the text. So far so good. That was easy, and got me hooked into doing more of it.

** What is this magic?
I'm using [[https://github.com/hlissner/doom-emacs][Doom Emacs]], installing things like C compilers and wiring them up is relatively easy, as Doom doctor told me which bits I was missing.
The  [[https://orgmode.org/worg/org-contrib/babel/languages/ob-doc-C.html][C, C++, D Source Code Blocks in Org Mode]] documentation got me through the first couple of code blocks.

This is a kind of magic, it also works on mac, and I don't even know which C compiler was used. Instead of typing commands, I can edit code live, and see the results instantly. Fast feedback is fun.
* My warm-up has warm-ups, exploring literate C programming

I wanted to do an exercise around quicksort from the book, but first, how can I use variables and stuff in my code.

** First named function with parameter: square
~+name: and :var~ let us name a program and pass a parameter to it.

 #+name: square
 #+header: :var x=97
 #+begin_src C :includes <stdio.h>
 printf("%d", x * x);
 #+end_src

 #+RESULTS: square
 : 9409

** Call a block by name
#+call: square(x=8)

#+RESULTS:
: 64

* An editors' table as input

One of the more 'tent' like aspects of C is that it does not have a package manager. There is [[https://github.com/silentbicycle/theft][Theft - Property-Based Testing for C]], but I thought i'd get to installing that later. Having a list of numbers as input would be good enough to start with.

I started with a table with just one column. org-mode graciously adds a header when calling ~org-create-table~, so in good ~C~ style I used one letter for the header, as it is just a bunch of numbers.

 #+tblname: unsorted
|    n |
|------|
| 2000 |
|   10 |
|  300 |

Let's just print the numbers, and see what we got, passing our named table as ~:var~. I renamed it to highlight what is source and destination.
#+name: c-table
#+header: :exports results
#+begin_src  C :var somedata=unsorted
  #include "stdlib.h"
  #include "stdio.h"
  int main()
  {
    for (int i=0; i<somedata_rows; i++) {
      printf ("%2d ", i); // print the column number
      // here I wanted to print the cell contents, but got segfaults on my initial code.
      printf("\n");
    }
    return 0;
  }
#+end_src

I wanted to print the cell contents, copying some code out of documentation I found. But I got segfaults instead. So a step back, and print just the row numbers, to see that we can get a table as output:

#+RESULTS: c-table
| 0 |
| 1 |
| 2 |

Tapping C-c C-v v, per the manual, gives us the generated source code. We get a two dimensional array out.
Here is part of the generated code that shows our 'unsorted' as 'somedata'.
#+begin_src C
int somedata[3][1] = {
 {1},
 {10},
 {3}
};
const int somedata_rows = 3;
const int somedata_cols = 1;
#+end_src

Our table has been turned into a two-dimensional array, with the rows first, and the columns second. We are only interested in one column


#+begin_quote
narrator: To prevent a segfault, willem should have read the copy-pasted types more closely, that would have saved him some debugging time. Using org syntax for the table did save him from looking up how to write this bit of boilerplate out in C.
#+end_quote

Rob later pointed out that a two-dimensional array in ~C~ is just a figment of your imagination. Nothing is stopping you from accessing it as a one dimensional array, or even a struct, if you feel so inclined.


* Two steps forward, one step back
The previous was an iteration of many steps. I kept getting segfaults when
trying to print the cell. So I was tempted to break out a debugger, since print
driven development does not seem to work for me here.

But stepping away for a bit, and actually reading the code that I dilligently
copy pasted... the column has already been converted to ints.

Since printf is stringly typed, we don't get a compiler error, but a segfault.
The code I pasted had ~const char*~ for the cell. We don't have char pointers (also known as strings) here, we have ints. So when we write that correctly, we can print the values.

#+name: c-table2
#+header: :exports results
#+begin_src  C :var somedata=unsorted
  #include "stdlib.h"
  #include "stdio.h"
  int main()
  {
    for (int i=0; i<somedata_rows; i++) {
      printf ("%2d ", i);
      printf("%2d ", somedata_cols);
      // should have called this row, but kept name from documentation code...
      int j=0;
      const int cell = somedata[i][j];
      printf("%2d ", cell);
      printf("\n");
    }
    return 0;
  }
#+end_src

#+RESULTS: c-table2
| 0 | 1 | 2000 |
| 1 | 1 |   10 |
| 2 | 1 |  300 |

Ok, so we know how to input, and output a table of numbers. We can use this as a kind of example based test for our QuickSort.

* Now we can call the built-in qsort.
 So The Practice Of Programming has a QuickSort example, and asks the reader to convert it from recursive to iterative. In C. I managed to sketch out an iterative example on paper, but I know too little of allocation in C to do that in one go. A baby step would be to convert the recursive calls to pushes on our own stack, and iterate until the stack is empty. Starting off with pushing the initial interval on the stack.

 An optimization could then be to keep current_interval, and only push the right hand side of the division on the stack. But we'd need some kind of test. Tables are a nice start. Further on in the book, they remark there is a standard implementation called 'qsort'.

 So lets' start with using ~qsort~ from the standard library. Ths took me a couple of tries, I had accidentally put my ~#include~ s inside the ~main~. It requires a comparator function. The book, provided ~icmp~, so I typed that in:

#+name: qsort_builtin
#+header: :exports results
#+begin_src C
#include "stdlib.h"
#include "stdio.h"

/* icmp: integer compare of *p1 and *p2 */
int icmp(const char * p1, const char * p2) {
  int v1, v2;

  v1 = *p1;
  v2 = *p2;

  if (v1 < v2)
      return -1;
  else if (v1 == v2)
      return 0;
  else
      return 1;
}

int main() {
    const int N = 3;
    int arr[3] = { -100, 10, 3 };
    qsort(arr, N, sizeof(int), icmp );
    // qsort modifies arr in place, and we can't
    // return a list from main. so print it instead
    for(int i=0; i<N;i++) {
       printf("%2d ", arr[i]);
       printf("\n"); // newline gives us the table rendering
    }
}
#+end_src

#+RESULTS: qsort_builtin
| -100 |
|    3 |
|   10 |

So, we can call a library function. C doesn't come with much out of the box, don't try finding data structures such as a stack in it. This was common for mainstream languages up until about Java. But we have ~qsort~, so we can build the scaffolding we need for our own version of it.

* Extract the comparator
Extract out ~icmp~ in its' own org-mode block, so I don't have to repeat it all the time:
#+name: icmp
#+header: :exports code
#+header: :tangle yes
#+header: :tangle icmp.h
#+header: :noweb yes
#+begin_src C :main no :cache yes :file icmp.h
/* icmp: integer compare of *p1 and *p2 */
int icmp(const void * p1, const void * p2) {
  int v1, v2;

  v1 = *(int *) p1;
  v2 = *(int *) p2;

  if (v1 < v2)
      return -1;
  else if (v1 == v2)
      return 0;
  else
      return 1;
}

#+end_src

#+RESULTS[19f647ab2dfe461c63a6e1fa5d06e05b03e89009]: icmp

This broke down, and was a large step, as it was / is not obvious how to export just some code to a file, in the same location as the next block.
Eventually, I got it working, after [[*Four tabs for tangling code blocks in org-mode][Four browser tabs]]. I almost gave up - there is always the option to use ~.h~ and ~.c~ files in an IDE,  and not use literate programming for learning. *Almost*, I am glad I got this working. The ~:tangle~ headers above are now unnecessary. The ~:exports~ header prevents execution of the code block, which is useful, as there is nothing to execute. I'll leave them in the text as evidence of my going around in circles.~

Cool, we have a function. Now we need to tell org-babel how to use it. ~<<icmp>>~ works, as long as we have the ~:noweb yes~ header in both the source and destination block.

* A horizontal table

I sort of started almost writing a test there, at the top of main. Some sample data to kick off the sort. I didn't use org-mode for a table, because I got all rows, and didn't want to do array manipulation just to get some data.

Stepping away from the keyboard, I realised that if I layed out the table in org-mode horizontally, I didn't need much magic.
Now for our horizontal table:
 #+tblname: unsorted_horizontal
| 1 | 0 | -100 | 10 | 420 |

Then assign it to the variable we had before, so we can take a tiny step.

Let's give this block a separate name, otherwise the RESULTS block will end up with the previous one.
#+name: qsort_builtin_refactored
#+header: :exports results
#+header: :noweb yes
#+begin_src C :var unsorted=unsorted_horizontal
#include "stdlib.h"
#include "stdio.h"
<<icmp>>
int main() {
    int N = 5;
    // get the first row of our one-row table
    int* arr = unsorted[0];

    qsort(arr, N, sizeof(int), icmp );
    // print the array
    for(int i=0; i<N;i++) {
       printf("%2d ", arr[i]);
    }
    printf("\n");
}
#+end_src

#+RESULTS: qsort_builtin_refactored
: -100  0  1 10 42

And it works as expected, all nicely sorted :-).

* Some of the blocks re-refactored by the QWAN ensemble

So this post isn't even going to make it to QuickSort by the book. I showed the above to Rob and Marc yesterday, and we had some more fun. Marc and I learnt C in trial by fire style, as part of our operating systems class in Uni. 'but we don't know C', 'You'll pick it up'. Rob was actually taught C for a whole two weeks (not much, given the care one needs to use it safely. ).

Anyway. Marc and Rob remembered some things to make the code more interesting, and in some cases, tidier. So the ~const void *~ in the ~icmp~ parameter list could be ~const int *~

aside: reading the symbols aloud
#+begin_quote
I notice I'm not reading ~const int star~ but ~const int pointer~. Reading the symbols out loud (for some definition of out loud) helps in understanding the code while you read. I'm pointing this out, because I forgot about this while practicing Haskell, and a freshly graduated hire that I was on-boarding through bits of pair-programming asked me what I called the symbols. After about two symbols I went ehhh... and had to look up the documentation.
C and C++ code can be equally cryptic, verbalising the symbols can help reinforce your understanding of the code. When you don't know how to pronounce a symbol, look it up.
#+end_quote

Mind you, I'm not saying 'curly brace', there are limits. Maybe I should try that some time.

Anyway, changing the coid pointers to int pointers allows us to get rid of a cast, so  ~v1 = *(int *) p1~ becomes ~v1 = *p1~. Since I got the definition of ~icmp~ from [[https://www.cs.princeton.edu/~bwk/tpop.webpage/][The Practice Of Programming]] , there may be something we overlooked here, let us know if you know what it is.

I find it interesting that the only place in ~qsort~ where the type of the actual data is needed is the ~icmp~ function. When I learnt C I thought function pointers, like ~icmp~ here, were some kind of voodoo. After wrting endless ~collect:~ (smalltalk, ruby) blocks, ~folds~ and ~traverses~ (Haskell, Purescript) and similar in Python, C# and finally even Java it is now an oasis of calm in a sea of void pointers and typecasts.

Another thing I didn't like about my solution above, with the array in the code, was that I failed to get rid of the magic number '3' for the size of the array. I hadn't figured out how to use N instead.

Marc found an answer, and then we iterated on it. "If you make that N a const, then you can use it in the array inialiser" Marc said.

    #+begin_src C
    const int N = 3;
    int arr[N] = { -100, 10, 3 };
    #+end_src

    #+RESULTS:

    That compiles, and more importantly, works. We still weren't as happy with the ~3~ there. It is duplicated implicitly, since we have 3 items in the array, and we write it in the const declaration. Can we find out the length of the array? "Yes we can" goes Rob. But it is not what you think it is. I go: I don't think there is 'length', or 'len' since typing 'th' would surely be too strenuous. Let alone reading it. Rob came up with this gem:

   #+begin_src C
    int arr[] = { 42, -100, 10, 3 };
    const int N = sizeof(arr) / sizeof(int);
    #+end_src

    The size in the array initializer is not needed. I just got sucked in by the overly communicative code generated by org-mode.
    #+begin_quote
Narrator: this was snark, there is no such thing as being overly communicative in code. Willem found comfort in seeing the dimensions of the table he had in text reflected in the generated code.
    #+end_quote

    ~sizeof(arr) / sizeof(int)~ I don't know how Rob came up with this, I hadn't seen it before. Brilliant, if a bit scary. It should be fine, assuming we don't have zero sized integers, and the array's size is a clean multiple of the size of the int.

    Meanwhile I'm changing some of the numbers each time, just to be sure the code is actually run. Focusing on one thing at a time is hard, and I still am not fully confident in my code-in-org-mode abilities.

    The reason we have to pass the length of the array to ~qsort~ is probably that we can't pass the name of our type ~int~ as a a parameter, so ~qsort~ has no way to ask the length of the array.

    Anwyay, having our int pointers makes it more obvious what is going on here. In C, usually pointers have the same size as integers. Qsort doesn't care if we sort pointers to structs, or integers, as long as it gets it's ~icmp~. So we dereference our fake int pointer to an int ~v1 = *p1~; and everyone is happy.

* Extract print_array

We'll extract the ~print_array~ helper in its' own
block, it is getting a bit repetitive.

#+name: print_array
#+header: :exports code
#+header: :noweb yes
#+header: :main no
#+begin_src C
#include "stdio.h"
/* print_array: print an array of integers of length N to stdout */
void print_array(const int* xs, int N) {
    for(int i=0; i<N;i++) {
       printf("%2d ", xs[i]);
    }
    printf("\n");
}
#+end_src

#+RESULTS: print_array

#+name: qsort_builtin_fewer_casts_remove_magic_number
#+header: :exports results :noweb yes
#+begin_src C
#include "stdlib.h"
#include "stdio.h"
<<icmp>>
<<print_array>>
int main() {
    int arr[] = { 20000, 1, 42, -100, 10, 3 };
    const int N = sizeof(arr) / sizeof(int);
    qsort(arr, N, sizeof(int), icmp );
    print_array(arr, N);
}
#+end_src

#+RESULTS: qsort_builtin_fewer_casts_remove_magic_number
: -100  1  3 10 42 20000

#+begin_quote
Documenting my steps helped here already. I had forgotten how to include blocks like ~<<icmp>>~ and ~<<print_array>>~. My notes above said I need :noweb yes.
#+end_quote



* Four tabs for tangling code blocks in org-mode
1. [[https://orgmode.org/manual/Noweb-Reference-Syntax.html#Noweb-Reference-Syntax][Noweb Reference Syntax (The Org Manual)]] how to reuse code in multiple blocks.
2. [[https://orgmode.org/guide/Working-with-Source-Code.html][Working with Source Code (Org Mode Compact Guide)]] how to evaluate source code
and using header arguments.
3. [[https://kitchingroup.cheme.cmu.edu/blog/2019/02/12/Using-results-from-one-code-block-in-another-org-mode/][Using results from one code block in another]]  was
more useful for evaluating code than combining multiple blocks. I did learn about the :cache
header for caching output that takes a long time to compute, only updating it
when the source code block changes. I didn't need it here, but useful for future
reference.
[[https://orgmode.org/worg/org-contrib/babel/languages/ob-doc-C.html][C, C++, D Source Code Blocks in Org Mode]] This is the one I started
with. Very useful, but doesn't have the information on reusing code from another block.

I still would like to know how to output ~icmp~ to its' own .h file, and use that in another block.
